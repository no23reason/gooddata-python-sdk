# (C) 2025 GoodData Corporation
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import sys
import typing

import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class FlightDescriptor(google.protobuf.message.Message):
    """This is a copy of part of the Flight RPC proto available at
    https://github.com/apache/arrow/blob/main/format/Flight.proto

    We need this because the PollInfo is not yet part of the PyArrow package and we want to be future compatible
    for when it is.


    The name or tag for a Flight. May be used as a way to retrieve or generate
    a flight or be used to expose a set of previously defined flights.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _DescriptorType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DescriptorTypeEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FlightDescriptor._DescriptorType.ValueType],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: FlightDescriptor._DescriptorType.ValueType  # 0
        """Protobuf pattern, not used."""
        PATH: FlightDescriptor._DescriptorType.ValueType  # 1
        """
        A named path that identifies a dataset. A path is composed of a string
        or list of strings describing a particular dataset. This is conceptually
         similar to a path inside a filesystem.
        """
        CMD: FlightDescriptor._DescriptorType.ValueType  # 2
        """
        An opaque command to generate a dataset.
        """

    class DescriptorType(_DescriptorType, metaclass=_DescriptorTypeEnumTypeWrapper):
        """
        Describes what type of descriptor is defined.
        """

    UNKNOWN: FlightDescriptor.DescriptorType.ValueType  # 0
    """Protobuf pattern, not used."""
    PATH: FlightDescriptor.DescriptorType.ValueType  # 1
    """
    A named path that identifies a dataset. A path is composed of a string
    or list of strings describing a particular dataset. This is conceptually
     similar to a path inside a filesystem.
    """
    CMD: FlightDescriptor.DescriptorType.ValueType  # 2
    """
    An opaque command to generate a dataset.
    """

    TYPE_FIELD_NUMBER: builtins.int
    CMD_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    type: global___FlightDescriptor.DescriptorType.ValueType
    cmd: builtins.bytes
    """
    Opaque value used to express a command. Should only be defined when
    type = CMD.
    """
    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """
        List of strings identifying a particular dataset. Should only be defined
        when type = PATH.
        """

    def __init__(
        self,
        *,
        type: global___FlightDescriptor.DescriptorType.ValueType = ...,
        cmd: builtins.bytes = ...,
        path: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["cmd", b"cmd", "path", b"path", "type", b"type"]) -> None: ...

global___FlightDescriptor = FlightDescriptor

@typing.final
class FlightInfo(google.protobuf.message.Message):
    """
    The access coordinates for retrieval of a dataset. With a FlightInfo, a
    consumer is able to determine how to retrieve a dataset.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SCHEMA_FIELD_NUMBER: builtins.int
    FLIGHT_DESCRIPTOR_FIELD_NUMBER: builtins.int
    ENDPOINT_FIELD_NUMBER: builtins.int
    TOTAL_RECORDS_FIELD_NUMBER: builtins.int
    TOTAL_BYTES_FIELD_NUMBER: builtins.int
    ORDERED_FIELD_NUMBER: builtins.int
    APP_METADATA_FIELD_NUMBER: builtins.int
    schema: builtins.bytes
    """The schema of the dataset in its IPC form:
      4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
      4 bytes - the byte length of the payload
      a flatbuffer Message whose header is the Schema
    """
    total_records: builtins.int
    """Set these to -1 if unknown."""
    total_bytes: builtins.int
    ordered: builtins.bool
    """
    FlightEndpoints are in the same order as the data.
    """
    app_metadata: builtins.bytes
    """
    Application-defined metadata.

    There is no inherent or required relationship between this
    and the app_metadata fields in the FlightEndpoints or resulting
    FlightData messages. Since this metadata is application-defined,
    a given application could define there to be a relationship,
    but there is none required by the spec.
    """
    @property
    def flight_descriptor(self) -> global___FlightDescriptor:
        """
        The descriptor associated with this info.
        """

    @property
    def endpoint(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FlightEndpoint]:
        """
        A list of endpoints associated with the flight. To consume the
        whole flight, all endpoints (and hence all Tickets) must be
        consumed. Endpoints can be consumed in any order.

        In other words, an application can use multiple endpoints to
        represent partitioned data.

        If the returned data has an ordering, an application can use
        "FlightInfo.ordered = true" or should return the all data in a
        single endpoint. Otherwise, there is no ordering defined on
        endpoints or the data within.

        A client can read ordered data by reading data from returned
        endpoints, in order, from front to back.

        Note that a client may ignore "FlightInfo.ordered = true". If an
        ordering is important for an application, an application must
        choose one of them:

        * An application requires that all clients must read data in
          returned endpoints order.
        * An application must return the all data in a single endpoint.
        """

    def __init__(
        self,
        *,
        schema: builtins.bytes = ...,
        flight_descriptor: global___FlightDescriptor | None = ...,
        endpoint: collections.abc.Iterable[global___FlightEndpoint] | None = ...,
        total_records: builtins.int = ...,
        total_bytes: builtins.int = ...,
        ordered: builtins.bool = ...,
        app_metadata: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["flight_descriptor", b"flight_descriptor"]) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "app_metadata",
            b"app_metadata",
            "endpoint",
            b"endpoint",
            "flight_descriptor",
            b"flight_descriptor",
            "ordered",
            b"ordered",
            "schema",
            b"schema",
            "total_bytes",
            b"total_bytes",
            "total_records",
            b"total_records",
        ],
    ) -> None: ...

global___FlightInfo = FlightInfo

@typing.final
class PollInfo(google.protobuf.message.Message):
    """
    The information to process a long-running query.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INFO_FIELD_NUMBER: builtins.int
    FLIGHT_DESCRIPTOR_FIELD_NUMBER: builtins.int
    PROGRESS_FIELD_NUMBER: builtins.int
    EXPIRATION_TIME_FIELD_NUMBER: builtins.int
    progress: builtins.float
    """
    Query progress. If known, must be in [0.0, 1.0] but need not be
    monotonic or nondecreasing. If unknown, do not set.
    """
    @property
    def info(self) -> global___FlightInfo:
        """
        The currently available results.

        If "flight_descriptor" is not specified, the query is complete
        and "info" specifies all results. Otherwise, "info" contains
        partial query results.

        Note that each PollInfo response contains a complete
        FlightInfo (not just the delta between the previous and current
        FlightInfo).

        Subsequent PollInfo responses may only append new endpoints to
        info.

        Clients can begin fetching results via DoGet(Ticket) with the
        ticket in the info before the query is
        completed. FlightInfo.ordered is also valid.
        """

    @property
    def flight_descriptor(self) -> global___FlightDescriptor:
        """
        The descriptor the client should use on the next try.
        If unset, the query is complete.
        """

    @property
    def expiration_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """
        Expiration time for this request. After this passes, the server
        might not accept the retry descriptor anymore (and the query may
        be cancelled). This may be updated on a call to PollFlightInfo.
        """

    def __init__(
        self,
        *,
        info: global___FlightInfo | None = ...,
        flight_descriptor: global___FlightDescriptor | None = ...,
        progress: builtins.float | None = ...,
        expiration_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_progress",
            b"_progress",
            "expiration_time",
            b"expiration_time",
            "flight_descriptor",
            b"flight_descriptor",
            "info",
            b"info",
            "progress",
            b"progress",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_progress",
            b"_progress",
            "expiration_time",
            b"expiration_time",
            "flight_descriptor",
            b"flight_descriptor",
            "info",
            b"info",
            "progress",
            b"progress",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_progress", b"_progress"]
    ) -> typing.Literal["progress"] | None: ...

global___PollInfo = PollInfo

@typing.final
class Ticket(google.protobuf.message.Message):
    """
    An opaque identifier that the service can use to retrieve a particular
    portion of a stream.

    Tickets are meant to be single use. It is an error/application-defined
    behavior to reuse a ticket.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TICKET_FIELD_NUMBER: builtins.int
    ticket: builtins.bytes
    def __init__(
        self,
        *,
        ticket: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["ticket", b"ticket"]) -> None: ...

global___Ticket = Ticket

@typing.final
class Location(google.protobuf.message.Message):
    """
    A location to retrieve a particular stream from. This URI should be one of
    the following:
     - An empty string or the string 'arrow-flight-reuse-connection://?':
       indicating that the ticket can be redeemed on the service where the
       ticket was generated via a DoGet request.
     - A valid grpc URI (grpc://, grpc+tls://, grpc+unix://, etc.):
       indicating that the ticket can be redeemed on the service at the given
       URI via a DoGet request.
     - A valid HTTP URI (http://, https://, etc.):
       indicating that the client should perform a GET request against the
       given URI to retrieve the stream. The ticket should be empty
       in this case and should be ignored by the client. Cloud object storage
       can be utilized by presigned URLs or mediating the auth separately and
       returning the full URL (e.g. https://amzn-s3-demo-bucket.s3.us-west-2.amazonaws.com/...).

    We allow non-Flight URIs for the purpose of allowing Flight services to indicate that
    results can be downloaded in formats other than Arrow (such as Parquet) or to allow
    direct fetching of results from a URI to reduce excess copying and data movement.
    In these cases, the following conventions should be followed by servers and clients:

     - Unless otherwise specified by the 'Content-Type' header of the response,
       a client should assume the response is using the Arrow IPC Streaming format.
       Usage of an IANA media type like 'application/octet-stream' should be assumed to
       be using the Arrow IPC Streaming format.
     - The server may allow the client to choose a specific response format by
       specifying an 'Accept' header in the request, such as 'application/vnd.apache.parquet'
       or 'application/vnd.apache.arrow.stream'. If multiple types are requested and
       supported by the server, the choice of which to use is server-specific. If
       none of the requested content-types are supported, the server may respond with
       either 406 (Not Acceptable) or 415 (Unsupported Media Type), or successfully
       respond with a different format that it does support along with the correct
       'Content-Type' header.

    Note: new schemes may be proposed in the future to allow for more flexibility based
    on community requests.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    URI_FIELD_NUMBER: builtins.int
    uri: builtins.str
    def __init__(
        self,
        *,
        uri: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["uri", b"uri"]) -> None: ...

global___Location = Location

@typing.final
class FlightEndpoint(google.protobuf.message.Message):
    """
    A particular stream or split associated with a flight.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TICKET_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    EXPIRATION_TIME_FIELD_NUMBER: builtins.int
    APP_METADATA_FIELD_NUMBER: builtins.int
    app_metadata: builtins.bytes
    """
    Application-defined metadata.

    There is no inherent or required relationship between this
    and the app_metadata fields in the FlightInfo or resulting
    FlightData messages. Since this metadata is application-defined,
    a given application could define there to be a relationship,
    but there is none required by the spec.
    """
    @property
    def ticket(self) -> global___Ticket:
        """
        Token used to retrieve this stream.
        """

    @property
    def location(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Location]:
        """
        A list of URIs where this ticket can be redeemed via DoGet().

        If the list is empty, the expectation is that the ticket can only
        be redeemed on the current service where the ticket was
        generated.

        If the list is not empty, the expectation is that the ticket can be
        redeemed at any of the locations, and that the data returned will be
        equivalent. In this case, the ticket may only be redeemed at one of the
        given locations, and not (necessarily) on the current service. If one
        of the given locations is "arrow-flight-reuse-connection://?", the
        client may redeem the ticket on the service where the ticket was
        generated (i.e., the same as above), in addition to the other
        locations. (This URI was chosen to maximize compatibility, as 'scheme:'
        or 'scheme://' are not accepted by Java's java.net.URI.)

        In other words, an application can use multiple locations to
        represent redundant and/or load balanced services.
        """

    @property
    def expiration_time(self) -> global___Timestamp:
        """
        Expiration time of this stream. If present, clients may assume
        they can retry DoGet requests. Otherwise, it is
        application-defined whether DoGet requests may be retried.
        """

    def __init__(
        self,
        *,
        ticket: global___Ticket | None = ...,
        location: collections.abc.Iterable[global___Location] | None = ...,
        expiration_time: global___Timestamp | None = ...,
        app_metadata: builtins.bytes = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["expiration_time", b"expiration_time", "ticket", b"ticket"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "app_metadata",
            b"app_metadata",
            "expiration_time",
            b"expiration_time",
            "location",
            b"location",
            "ticket",
            b"ticket",
        ],
    ) -> None: ...

global___FlightEndpoint = FlightEndpoint

@typing.final
class Timestamp(google.protobuf.message.Message):
    """Copy of https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SECONDS_FIELD_NUMBER: builtins.int
    NANOS_FIELD_NUMBER: builtins.int
    seconds: builtins.int
    """Represents seconds of UTC time since Unix epoch
    1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    9999-12-31T23:59:59Z inclusive.
    """
    nanos: builtins.int
    """Non-negative fractions of a second at nanosecond resolution. Negative
    second values with fractions must still have non-negative nanos values
    that count forward in time. Must be from 0 to 999,999,999
    inclusive.
    """
    def __init__(
        self,
        *,
        seconds: builtins.int = ...,
        nanos: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["nanos", b"nanos", "seconds", b"seconds"]) -> None: ...

global___Timestamp = Timestamp
